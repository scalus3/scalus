package scalus.uplc.transform

import scalus.uplc.DefaultFun.IfThenElse
import scalus.uplc.Term
import scalus.uplc.Term.{Apply, Builtin, Case, Const, Constr, Delay, Error, Force, LamAbs, Var}
import scalus.uplc.TermDSL.given

import scala.language.implicitConversions

/** Optimizes if-then-else expressions by converting lazy branches to strict evaluation when safe.
  *
  * ==Background==
  *
  * UPLC (Untyped Plutus Core) uses strict evaluation: all function arguments are evaluated before
  * the function is applied. However, for conditional expressions using `IfThenElse`, we need lazy
  * evaluation to avoid evaluating both branches.
  *
  * The standard compilation generates:
  * {{{
  * Force(Apply(Apply(Apply(Force(Builtin(IfThenElse)), condition), Delay(thenBranch)), Delay(elseBranch)))
  * }}}
  *
  * This pattern has a cost:
  *   - 2 `Delay` nodes to suspend branch evaluation
  *   - 1 `Force` node to evaluate the selected branch
  *   - Total: '''3 extra term node evaluations per if-then-else'''
  *
  * ==The Optimization==
  *
  * When both branches are "simple values" that evaluate to exactly 1 term, we can safely evaluate
  * them strictly, removing the Delay/Force overhead:
  * {{{
  * Apply(Apply(Apply(Force(Builtin(IfThenElse)), condition), thenBranch), elseBranch)
  * }}}
  *
  * This saves 3 term node evaluations, improving performance without changing semantics.
  *
  * ==Simple Values (Single-Term Evaluation)==
  *
  * A term is considered "simple" if it evaluates to exactly 1 term:
  *   - `Var`: Variable lookup (1 term)
  *   - `Const`: Constant value (1 term)
  *   - `LamAbs`: Lambda abstraction - not executed until applied (1 term)
  *   - `Builtin`: Builtin function reference - not executed until applied (1 term)
  *   - `Delay`: Suspended computation - not executed (1 term)
  *   - `Constr(_, Nil)`: Empty constructor (1 term)
  *
  * Terms that are NOT simple (multi-term evaluation):
  *   - `Apply`: Requires evaluating function + argument (3+ terms)
  *   - `Force`: Requires evaluating the forced term (2+ terms)
  *   - `Case`: Requires evaluating scrutinee + pattern matching (2+ terms)
  *   - `Constr(_, args)` with args: Requires evaluating each argument (1 + n terms)
  *   - `Error`: Will fail immediately
  *
  * ==Example==
  *
  * {{{
  * // Original: if condition then 42 else 100
  * Force(Apply(Apply(Apply(Force(Builtin(IfThenElse)), condition), Delay(Const(42))), Delay(Const(100))))
  * // Cost: 5 term evaluations (Force + Apply + Apply + Apply + Force + 2 Delay + selected Const)
  *
  * // Optimized: both branches are constants (simple values)
  * Apply(Apply(Apply(Force(Builtin(IfThenElse)), condition), Const(42)), Const(100))
  * // Cost: 2 term evaluations (Force + Apply + Apply + Apply + selected Const)
  * // Savings: 3 term evaluations (2 Delay + 1 Force)
  * }}}
  *
  * @see
  *   [[scalus.uplc.transform.EtaReduce]] for another UPLC optimization
  * @see
  *   [[scalus.uplc.transform.Inliner]] for beta-reduction and dead code elimination
  */
object StrictIf {

    /** Applies the strict if-then-else optimization without logging.
      *
      * @param term
      *   The UPLC term to optimize
      * @return
      *   The optimized term
      */
    def apply(term: Term): Term = strictIf(term, _ => ())

    /** Applies the strict if-then-else optimization with logging.
      *
      * @param term
      *   The UPLC term to optimize
      * @param logger
      *   Function to log optimization events
      * @return
      *   The optimized term
      */
    def apply(term: Term, logger: String => Unit): Term = strictIf(term, logger)

    /** Performs the strict if-then-else optimization by traversing the term tree.
      *
      * @param term
      *   The UPLC term to optimize
      * @param logger
      *   Function to log optimization events
      * @return
      *   The optimized term
      */
    def strictIf(term: Term, logger: String => Unit): Term = {
        def go(term: Term): Term = term match
            // Pattern: Force(Apply(Apply(Apply(Force(Builtin(IfThenElse)), c), Delay(t)), Delay(f)))
            // This is the standard lazy if-then-else pattern generated by the compiler
            case Force(
                  Apply(Apply(Apply(Force(Builtin(IfThenElse)), c), Delay(t)), Delay(f))
                ) =>
                // First recursively optimize the branches and condition
                val optimizedT = go(t)
                val optimizedF = go(f)
                val optimizedC = go(c)

                // Check if both optimized branches are simple values (single-term evaluation)
                if canBeStrict(optimizedT) && canBeStrict(optimizedF) then
                    // We can safely remove the Delay wrappers and outer Force
                    // Result: Apply(Apply(Apply(Force(Builtin(IfThenElse)), c), t), f)
                    logger(s"StrictIf: Converting lazy if-then-else to strict (saves 3 term evals)")
                    !IfThenElse $ optimizedC $ optimizedT $ optimizedF
                else
                    // Keep the lazy form with optimized subterms
                    Force(
                      Apply(
                        Apply(Apply(Force(Builtin(IfThenElse)), optimizedC), Delay(optimizedT)),
                        Delay(optimizedF)
                      )
                    )

            // Recursively optimize subterms
            case Apply(f, a)        => Apply(go(f), go(a))
            case LamAbs(name, body) => LamAbs(name, go(body))
            case Force(t)           => Force(go(t))
            case Delay(t)           => Delay(go(t))
            case Constr(tag, args)  => Constr(tag, args.map(arg => go(arg)))
            case Case(scrutinee, cases) =>
                Case(
                  go(scrutinee),
                  cases.map(go)
                )

            // Atomic terms: no transformation needed
            case _: Var | _: Const | _: Builtin | Error => term

        go(term)
    }

    /** Checks if a term is a "simple value" that evaluates to exactly 1 term.
      *
      * A term can be evaluated strictly (without Delay/Force) only if it's a simple value that
      * requires exactly 1 term node evaluation. This ensures the optimization doesn't increase
      * evaluation cost.
      *
      * Single-term values:
      *   - Variables: Just a lookup (1 term)
      *   - Constants: Literal values (1 term)
      *   - Lambda abstractions: Function definitions, not executed (1 term)
      *   - Builtins: Function references, not executed until applied (1 term)
      *   - Delays: Suspended computations, not executed (1 term)
      *   - Empty constructors: No arguments to evaluate (1 term)
      *
      * Multi-term values (NOT simple):
      *   - Apply: Function + argument evaluation (3+ terms)
      *   - Force: Forced term evaluation (2+ terms)
      *   - Case: Scrutinee + pattern matching (2+ terms)
      *   - Non-empty Constr: Constructor + each argument (1 + n terms)
      *   - Error: Will fail immediately
      *
      * @param term
      *   The term to check
      * @return
      *   true if the term evaluates to exactly 1 term node, false otherwise
      */
    private def canBeStrict(term: Term): Boolean = term match
        // Multi-term evaluation: function application requires evaluating both function and argument
        case _: Apply => false

        // Single-term evaluation: atomic values that don't execute nested computations
        case _: Var | _: Const | _: LamAbs | _: Delay | _: Builtin => true

        // Single-term evaluation: empty constructor has no arguments to evaluate
        case Constr(_, Nil) => true

        // Multi-term evaluation or failure:
        // - Error: will fail immediately
        // - Force: requires evaluating the forced term (2+ terms)
        // - Case: requires evaluating scrutinee + pattern matching (2+ terms)
        // - Constr with args: requires evaluating each argument (1 + n terms)
        case Error | _: Force | _: Case | _: Constr => false
}
