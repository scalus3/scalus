---
title: Stake Validator Pattern
sidebarTitle: Stake Validator
description: Reduce execution costs for multi-input transactions using the withdraw zero trick.
---

import { Callout } from 'nextra/components'

# Stake Validator Pattern

Delegate computation to a staking script using the "withdraw zero trick" to reduce execution costs from O(N²) to O(N).

## The Challenge

When a Cardano validator processes multiple UTxOs in a single transaction, the spending script runs once per input. If each execution performs expensive operations (iterating all inputs, checking all outputs), costs grow quadratically:

- **10 inputs** = 10 script executions × 10 iterations = 100 operations
- **20 inputs** = 20 script executions × 20 iterations = 400 operations

This makes batch operations prohibitively expensive.

## How It Works

1. **Spending validator** (runs per UTxO): Minimal logic - just checks stake validator ran
2. **Stake validator** (runs once): Heavy computation in the reward endpoint

The spending validator essentially says: "As long as there is a reward withdrawal of the given script in this transaction, this UTxO can be spent."

## When to Use This Pattern

**Best for:**
- Consolidating complex business logic into a single validation point
- Batch operations processing multiple UTxOs together
- Separating payment validation from protocol logic (better composability)
- Reducing script size and execution costs

**Not ideal for:**
- Single input transactions (no benefit)
- Cases where each input needs unique, complex validation
- Protocols where staking credentials aren't suitable

## API Reference

| Function | Description |
|----------|-------------|
| `spend` | Check stake validator ran + validate its redeemer and withdrawal amount |
| `spendMinimal` | Just check stake validator ran (most common) |
| `withdraw` | Helper for reward endpoint - extracts script hash from credential |

## Implementation Guide

### Spending Endpoint

```scala
import scalus.patterns.StakeValidator

@Compile
object MyValidator extends Validator {
    inline override def spend(
        datum: Option[Data],
        redeemer: Redeemer,
        tx: TxInfo,
        ownRef: TxOutRef
    ): Unit = {
        val ownScriptHash = tx.findOwnInputOrFail(ownRef).resolved.address.credential
            .scriptOption.getOrFail("Own address must be Script")

        // Option 1: Just check stake validator ran (withdraw zero trick)
        StakeValidator.spendMinimal(ownScriptHash, tx)

        // Option 2: Also validate redeemer and withdrawal amount
        StakeValidator.spend(
          withdrawalScriptHash = ownScriptHash,
          withdrawalRedeemerValidator = (redeemer, lovelace) => lovelace === BigInt(0),
          txInfo = tx
        )
    }
}
```

### Reward Endpoint (Stake Validator)

```scala
inline override def reward(
    redeemer: Redeemer,
    stakingKey: Credential,
    tx: TxInfo
): Unit = {
    StakeValidator.withdraw(
      withdrawalValidator = (redeemer, validatorHash, txInfo) => {
          // Your heavy validation logic here
          // This runs ONCE for all inputs
          val totalInputValue = txInfo.inputs.foldLeft(BigInt(0)) { (acc, input) =>
              acc + input.resolved.value.getLovelace
          }
          // Verify outputs match expected distribution
          true
      },
      redeemer = redeemer,
      credential = stakingKey,
      txInfo = tx
    )
}
```

<Callout type="warning">
**Script Configuration:** The spending script address must have a staking credential that points to your withdrawal validator. This is configured when deploying scripts.
</Callout>

<Callout type="warning">
**Double Satisfaction:** When using this pattern with multiple inputs, ensure proper input-to-output mapping to prevent double satisfaction vulnerabilities. See [Plutus Vulnerabilities](/docs/learning/plutus-vulnerabilities#3-double-satisfaction).
</Callout>

### Example: Payment Splitter

See `scalus.examples.StakeValidatorPaymentSplitterExample` for a complete implementation where:
- **Spending validator**: Uses `spendMinimal` to just verify stake validator runs
- **Stake validator**: Verifies payment distribution logic once for all inputs

```scala
// Payment splitter - spending endpoint is minimal
StakeValidator.spendMinimal(ownScriptHash, tx)

// All heavy logic in stake validator reward endpoint
inline override def reward(redeemer: Redeemer, stakingKey: Credential, tx: TxInfo): Unit = {
    val distribution = redeemer.to[PaymentDistribution]

    // Verify all recipients receive correct amounts
    distribution.payments.foreach { payment =>
        val output = tx.outputs.find(_.address === payment.recipient)
            .getOrFail("Missing recipient output")
        require(output.value.getLovelace >= payment.amount, "Insufficient payment")
    }
}
```

## Related Patterns

- **[Merkelized Validator](/docs/learning/design-patterns/merkelized-validator-pattern)** - When spending validators need to read verified data from stake validator
- **[Transaction Level Minter](/docs/learning/design-patterns/transaction-level-minter-pattern)** - Similar pattern using minting instead of staking

## Resources

- [Anastasia Labs: Stake Validator Pattern](https://github.com/Anastasia-Labs/design-patterns/tree/main/stake-validator) - Original pattern documentation
- [Scalus Design Patterns](https://github.com/scalus3/scalus/tree/master/scalus-design-patterns) - Implementation and tests
- [StakeValidatorPaymentSplitterExample](https://github.com/scalus3/scalus/blob/master/scalus-design-patterns/src/main/scala/scalus/examples/StakeValidatorPaymentSplitterExample.scala) - Complete example
