---
title: Debugging Cardano Smart Contracts
sidebarTitle: Debugging
description: Debug Cardano validators as regular Scala code. Use IDE debuggers, breakpoints, logging, error traces, and troubleshooting techniques for smart contracts.
---

# Debugging Cardano Smart Contracts

## Scala-Level Debugging

Before compiling to UPLC, you can debug your validator as regular Scala code:
- Use your IDE's debugger
- Set breakpoints in validator methods
- Step through execution
- Inspect variables and data structures

**This is the fastest way to debug logic errors.**

## Using `log` for Script Logging

The `log` function accepts **variadic arguments** of any type that has a `Show` or `ToData` instance. All arguments are converted to strings and concatenated into a single trace entry, separated by spaces.

```scala
inline def log(inline args: Any*): Unit
```

### Basic Usage

```scala
import scalus.cardano.onchain.plutus.prelude.log

// Simple message
log("Starting validation")

// Label with a value — uses Show[BigInt]
log("count", BigInt(42))
// trace output: "count 42"

// Multiple values
log("values", BigInt(1), BigInt(2), BigInt(3))
// trace output: "values 1 2 3"

// Mixed types — uses Show[Boolean] and Show[BigInt]
log("mixed", true, BigInt(42))
// trace output: "mixed True 42"
```

### How Arguments Are Converted

The `log` macro resolves each argument at compile time:

1. **String literals** — passed through as-is (unquoted), useful as labels
2. **Types with a `Show` instance** — converted via `Show[T]`. Built-in instances exist for `BigInt`, `Boolean`, `String`, `Data`, and `Unit`
3. **Types with a `ToData` instance** (fallback) — converted to `Data` first, then displayed via `Show[Data]`. This works for any case class or enum that `derives ToData`
4. **No instance found** — compilation error

```scala
// String literal vs string expression
val s: String = "hello"
log("label", s)
// trace output: label "hello"
// ↑ literal (unquoted)  ↑ expression (quoted via Show[String])
```

### Logging Custom Types

Any case class or enum with a `ToData` instance can be logged:

```scala
import scalus.cardano.onchain.plutus.prelude.*

case class Point(x: BigInt, y: BigInt) derives ToData

enum Color derives ToData:
    case Red, Green, Blue

// In your validator:
log("point", Point(BigInt(1), BigInt(2)))
// trace output: "point <0, [1, 2]>"  (Data representation)

log("color", Color.Red)
// trace output: "color <0, []>"
```

### Validator Example

```scala
import scalus.cardano.onchain.plutus.prelude.log

@Compile
object MyValidator extends Validator:
  inline override def spend(
      datum: Option[Data],
      redeemer: Data,
      tx: TxInfo,
      ownRef: TxOutRef
  ): Unit = {
    log("Starting validation")
    val myDatum = datum.getOrFail("Datum required").to[MyDatum]
    log("owner", myDatum.owner)

    val isValid = tx.isSignedBy(myDatum.owner)
    log("signed", isValid)

    require(isValid, "Must be signed by owner")
  }
```

### Notes

- `log()` with no arguments is a no-op
- Each `log(...)` call produces exactly **one** trace entry
- `log` compiles to `Builtins.trace`, so it consumes execution units on-chain. Remove or minimize logging for production deployments

## Where Do Logs Appear?

When scripts are evaluated (on-chain or via `PlutusScriptEvaluator`), logs are collected and included in:
- The `Result.Success` object (when evaluation succeeds)
- The `PlutusScriptEvaluationException` (when evaluation fails)

Off-chain, you can access logs through the evaluation result to understand what happened during script execution. This is particularly useful when debugging why a transaction failed validation.

## Evaluating with Error Traces

```scala
import scalus.uplc.eval.PlutusVM

given PlutusVM = PlutusVM.makePlutusV3VM()

val compiled = compile {
  log("Validator starting")
  // your validator code
  log("Validator completed")
}

// Evaluate with error traces enabled
val result = compiled.toUplc(generateErrorTraces = true).evaluateDebug
```

**The `generateErrorTraces` flag:**
- `true`: Adds error location information (useful for debugging, but increases script size)
- `false`: Minimal script size (for production deployment)

## Debugging with IDE

One of Scalus's biggest advantages is the ability to debug validators as regular Scala code:

### Setting Up Debug Mode

1. **Run tests in debug mode** - Use your IDE's debug test runner
2. **Set breakpoints** - Click in the gutter next to line numbers
3. **Inspect variables** - Hover over variables or use the debug panel
4. **Step through code** - Use step over, step into, step out

### Example Debug Session

```scala
@Compile
object MyValidator extends Validator:
  inline override def spend(
      datum: Option[Data],
      redeemer: Data,
      tx: TxInfo,
      ownRef: TxOutRef
  ): Unit = {
    val owner = datum.getOrFail("No datum").to[PubKeyHash]
    // Set breakpoint here ⬅
    val signed = tx.signatories.contains(owner)
    // Inspect 'signed' variable
    require(signed, "Not signed")
  }
```

**Debugging workflow:**
1. Set a breakpoint in your validator
2. Run test in debug mode
3. When breakpoint hits, inspect variables
4. Step through execution to understand behavior
5. Fix logic errors before compiling to UPLC

## See Also

- **[Unit Testing](/docs/testing/unit-testing)** - Write comprehensive tests for your validators
- **[Emulator](/docs/testing/emulator)** - Test with in-memory Cardano node
- **[Local Devnet](/docs/testing/local-devnet)** - Integration testing with real Cardano node
- **[Compiling](/docs/smart-contracts/compiling)** - Compile debugged validators to Plutus scripts