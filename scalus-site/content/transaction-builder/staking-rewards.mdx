---
title: Cardano Staking & Rewards - Register, Delegate & Withdraw Rewards
description: Complete guide to Cardano staking & rewards operations with Scalus TxBuilder. Learn how to register stake keys, delegate to stake pools, withdraw rewards, and manage staking deposits on Cardano blockchain.
sidebarTitle: Staking & Rewards
---

import { Callout } from 'nextra/components'

# Cardano Staking: Delegate to Stake Pool, Withdraw Rewards

Scalus TxBuilder provides a type-safe API for managing Cardano staking operations. This guide covers the four core staking operations: registering stake keys, delegating to pools, withdrawing rewards, and deregistering stake keys.

<Callout type="info">
  Staking operations require interaction with Cardano's stake address system. All operations support both Byron-era and Conway-era protocol parameters.
</Callout>

## Registering Stake Keys

Registering a stake key is the first step to participate in Cardano staking. This operation requires a **2 ADA deposit** that is refundable when you deregister the stake key.

```scala copy
val tx = TxBuilder(env)
  .registerStake(stakeAddress)
  .complete(provider, sponsorAddress)
```

The deposit amount is automatically taken from protocol parameters (`env.protocolParams.stakeAddressDeposit`).

<Callout type="warning">
  The 2 ADA deposit is held by the protocol and will be returned when you deregister your stake key.
</Callout>

## Delegating to Stake Pools

After registering a stake key, you can delegate it to a stake pool using the pool's unique Pool ID. Your delegated ADA helps secure the network and earns staking rewards.

```scala copy
val poolId = PoolKeyHash.fromHex("pool1...")

val tx = TxBuilder(env)
  .delegateTo(stakeAddress, poolId)
  .complete(provider, sponsorAddress)
```

## Registering and Delegating in One Transaction

For efficiency, you can combine registration and delegation into a single transaction:

```scala copy
val poolId = PoolKeyHash.fromHex("pool1...")

val tx = TxBuilder(env)
  .stakeAndDelegate(stakeAddress, poolId)
  .complete(provider, sponsorAddress)
```

The deposit is automatically taken from protocol parameters.

<Callout type="info">
  Combining operations saves transaction fees and reduces the number of blockchain interactions required.
</Callout>

## Withdrawing Staking Rewards

Claim your accumulated staking rewards to your wallet.

```scala copy
val tx = TxBuilder(env)
  .withdrawRewards(stakeAddress, rewardAmount)
  .complete(provider, sponsorAddress)
```

<Callout type="warning">
  **Post-Vasil Era**: Stake rewards must be withdrawn fully. Partial withdrawals are not supported.
</Callout>

<Callout type="info">
  **Post-Chang Era**: Rewards are only withdrawable if you have delegated your voting power to a DRep (Delegated Representative). See the [Governance](/docs/transaction-builder/governance) guide for more information.
</Callout>

## Deregistering Stake Keys

Deregistering a stake key returns your initial 2 ADA deposit and removes your stake key from the blockchain.

```scala copy
val tx = TxBuilder(env)
  .deregisterStake(stakeAddress)
  .complete(provider, sponsorAddress)
```

With explicit refund:

```scala copy
val tx = TxBuilder(env)
  .deregisterStake(stakeAddress, Coin.ada(2))
  .complete(provider, sponsorAddress)
```

## Working with Stake Addresses

### Creating Stake Addresses from Key Hash

To perform staking operations, you need a properly formatted stake address. Here's how to create one from a stake key hash:

```scala copy
import scalus.cardano.address.{StakeAddress, StakePayload}

val stakeAddress = StakeAddress(
  Network.Mainnet,
  StakePayload.Stake(stakeKeyHash)
)
```

### Extracting Stake Address from Payment Address

You can extract the stake address from a Shelley payment address:

```scala copy
val stakeAddress = shelleyAddress.delegation match {
  case ShelleyDelegationPart.Key(keyHash) =>
    StakeAddress(shelleyAddress.network, StakePayload.Stake(keyHash))
  case _ => throw new Exception("No stake key")
}
```

## Script-Based Staking Operations

Scalus supports script-based stake credentials (post-Conway). Use the `ScriptWitness` factory methods to authorize operations from script-controlled stake addresses.

### Creating Script Stake Addresses

```scala copy
import scalus.cardano.address.{StakeAddress, StakePayload}

// Create a stake address controlled by a script
val scriptStakeAddress = StakeAddress(
  Network.Mainnet,
  StakePayload.Script(stakingScript.scriptHash)
)
```

### Withdrawing Rewards from Script Stake Address

```scala copy
import scalus.cardano.txbuilder.TwoArgumentPlutusScriptWitness.*

// With attached script (included in transaction)
val tx = TxBuilder(env)
  .spend(utxo)
  .collaterals(collateralUtxo)
  .withdrawRewards(scriptStakeAddress, rewardAmount, attached(stakingScript, redeemer))
  .complete(provider, sponsorAddress)

// With reference script (script already deployed on-chain)
val tx = TxBuilder(env)
  .spend(utxo)
  .collaterals(collateralUtxo)
  .references(scriptRefUtxo)
  .withdrawRewards(scriptStakeAddress, rewardAmount, reference(redeemer))
  .complete(provider, sponsorAddress)
```

### Delegating Script Stake Address

```scala copy
import scalus.cardano.txbuilder.TwoArgumentPlutusScriptWitness.*

val tx = TxBuilder(env)
  .spend(utxo)
  .collaterals(collateralUtxo)
  .delegateTo(scriptStakeAddress, poolId, attached(stakingScript, redeemer))
  .complete(provider, sponsorAddress)
```

### Registering Script Stake Key

```scala copy
import scalus.cardano.txbuilder.TwoArgumentPlutusScriptWitness.*

val tx = TxBuilder(env)
  .spend(utxo)
  .collaterals(collateralUtxo)
  .registerStake(scriptStakeAddress, attached(stakingScript, redeemer))
  .complete(provider, sponsorAddress)
```

### Deregistering Script Stake Key

```scala copy
import scalus.cardano.txbuilder.TwoArgumentPlutusScriptWitness.*

val tx = TxBuilder(env)
  .spend(utxo)
  .collaterals(collateralUtxo)
  .deregisterStake(scriptStakeAddress, attached(stakingScript, redeemer))
  .complete(provider, sponsorAddress)

// With explicit refund amount
val tx = TxBuilder(env)
  .spend(utxo)
  .collaterals(collateralUtxo)
  .deregisterStake(scriptStakeAddress, Some(Coin.ada(2)), attached(stakingScript, redeemer))
  .complete(provider, sponsorAddress)
```

<Callout type="info">
  For delayed redeemers (computed from the final transaction), pass a lambda: `attached(script, tx => computeRedeemer(tx))`
</Callout>

### Native Script Staking

You can also use native scripts for staking operations:

```scala copy
import scalus.cardano.txbuilder.NativeScriptWitness.*

val tx = TxBuilder(env)
  .spend(utxo)
  .withdrawRewards(nativeScriptStakeAddress, rewardAmount, attached(nativeScript))
  .complete(provider, sponsorAddress)
```

## See Also

- [Governance](/docs/transaction-builder/governance)
- [Building Your First Transaction](/docs/transaction-builder/building-first-transaction)
