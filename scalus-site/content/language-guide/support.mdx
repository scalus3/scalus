---
title: Supported Scala Features for Cardano Smart Contracts
sidebarTitle: Supported Features
description: Learn which Scala 3 features are supported when compiling to Plutus Core. Includes lambdas, pattern matching, higher-order functions, case classes, enums, and more.
---

# Supported Scala Features

Scalus compiles Scala code to Untyped Plutus Core (UPLC), a minimalist lambda calculus designed for secure blockchain execution. This constraint means only a subset of Scala's feature set is supportedâ€”those that can be efficiently and deterministically translated to UPLC.

The compilation process transforms your Scala code into an intermediate representation before generating the final UPLC that runs on Cardano. UPLC's deliberately limited nature (optimized for security and determinism) excludes many high-level language features.

## Supported Features

Below is a comprehensive list of what Scala features are currently supported in Scalus:

* simple `val`s and `def`s of supported built-in types or case classes/enums
* lambda expressions
* recursive functions
* passing/returning functions as arguments (higher-order functions)
* `if-then-else` expressions
* simple `match` expressions on case classes and enums
    * only simple bindings are supported like `case Costr(field, other) => ...`
* `given` arguments and `using` clauses
* `throw` expressions but no `try-catch` expressions
* built-in functions and operators
* simple data types: case classes and enums
* `inline` vals, functions and macros in general
* implicit conversions
* opaque types (non top-level) and type aliases
* extension methods
* tuples
* value destructuring in vals: `val Some((a, b)) = optionOfTuple` 

## Unsupported Features

* `var`s and `lazy val`s - use immutable `val` declarations instead
* `while` loops - use recursion or higher-order functions like `fold`
* classes, inheritance and polymorphism aka virtual dispatch
    * you can't use `isInstanceOf` or runtime type checks
    * use sealed traits with enums or case classes for polymorphic data
* `try-catch` expressions - use `Option`, `Either`, or error handling patterns instead
* overloaded functions - each function must have a unique name
* mutually recursive functions - functions cannot call each other recursively
