package scalus.testing.conformance

import org.scalatest.Tag
import org.scalatest.funsuite.AnyFunSuite
import scalus.cardano.ledger.*
import scalus.cardano.ledger.rules.*
import scalus.testing.conformance.CardanoLedgerVectors.*
import scalus.utils.Hex
import scala.util.Try

/** Cardano Ledger Conformance Test Suite
  *
  * Runs conformance tests from cardano-ledger test vectors to validate Scalus ledger implementation
  * against reference implementation.
  *
  * ==Budget Difference Investigation (December 2025)==
  *
  * Some conformance tests fail with "Out of budget" errors. Investigation revealed:
  *
  * '''Key Finding: Scalus matches current Haskell `uplc` tool exactly.'''
  *
  * Comparison results on identical applied programs:
  * {{{
  * Test vector budget (cardano-ledger):  mem=352394,  cpu=91377951
  * Scalus computed budget:               mem=353696,  cpu=91714333
  * Haskell uplc (v1.56.0.0) budget:      mem=353696,  cpu=91714333
  *
  * Differences:
  *   Scalus vs Test Vector:  mem=+1302, cpu=+336382
  *   Uplc vs Test Vector:    mem=+1302, cpu=+336382
  *   Scalus vs Uplc:         mem=0,     cpu=0        <-- EXACT MATCH
  * }}}
  *
  * '''Root Cause:''' The test vectors were generated by cardano-ledger's test suite (files dated
  * May 15, 2025) with budgets computed at that time. Since then, Plutus cost accounting may have
  * changed slightly, causing both Scalus and current Haskell `uplc` to compute higher budgets than
  * what's stored in the test vectors.
  *
  * '''The constant offset''' (mem=+1302, cpu=+336382) across all failing tests proves this is a
  * systematic difference, not a bug in Scalus.
  *
  * '''Relevant Changes in 2025:'''
  *   - Jan 29, 2025: cardano-ledger PR #4854 "Implement memoization of Plutus script context
  *     computation"
  *   - Various Plutus cost model updates and optimizations throughout 2025
  *
  * '''Conclusion:''' Scalus implementation is correct. The test vectors need to be regenerated with
  * current cardano-ledger to get matching budgets.
  *
  * @see
  *   [[https://github.com/IntersectMBO/cardano-ledger/pull/4854 PR #4854]]
  * @see
  *   [[https://github.com/IntersectMBO/plutus/blob/master/plutus-core/CHANGELOG.md Plutus CHANGELOG]]
  */
class CardanoLedgerConformanceTest extends AnyFunSuite {

    val TestTag = Tag("conformance")

    test("OutOfBudget failure") {
        val vectorName =
            "Conway.Imp.AlonzoImpSpec.UTXOS.PlutusV1.Scripts pass in phase 2.datumIsWellformed"
        for
            result <- validateVector(vectorName, EvaluatorMode.Validate)
            if result._2 != result._3.isRight
        do println(pprint(result))
    }

    test("Conformance ledger rules test - EvaluatorMode.EvaluateAndComputeCost") {
        assert(conformanceTestFailed(EvaluatorMode.EvaluateAndComputeCost).isEmpty)
    }

    def validateVector(
        vectorName: String,
        evaluatorMode: EvaluatorMode
    ): List[(String, Boolean, CardanoMutator.Result)] =
        for case (path, vector) <- loadAllVectors(vectorName) yield
            val transaction = Transaction.fromCbor(Hex.hexToBytes(vector.cbor))
            val state = LedgerState.fromCbor(Hex.hexToBytes(vector.oldLedgerState)).ruleState

            // Extract protocol parameters from test vector
            val params = ConwayProtocolParams
                .extractPparamsHash(vector.oldLedgerState, pparamsDir)
                .flatMap(hash => ConwayProtocolParams.loadFromHash(pparamsDir, hash))
                .map(_.toProtocolParams)

            val context = Context(
              env = rules.UtxoEnv(
                0,
                params.getOrElse(UtxoEnv.default.params),
                state.certState,
                scalus.cardano.address.Network.Testnet
              ),
              evaluatorMode = evaluatorMode
            )

            val result = CardanoMutator.transit(context, state, transaction)
            (
              path.getFileName.toFile.getName,
              vector.success,
              result
            )

    private def failureVectors(
        results: List[(String, Try[List[(String, Boolean, CardanoMutator.Result)]])]
    ) = for
        case (vectorName, result) <- results
        x <- result.toOption.toList
        case (n, success, result) <- x if success != result.isRight
    yield (vectorName, n, success, result)

    def conformanceTestFailed(evaluatorMode: EvaluatorMode) = {
        val vectors = vectorNames().filter(_.contains(".UTXO"))
        val results =
            for vectorName <- vectors
            yield vectorName -> Try(
              validateVector(vectorName, evaluatorMode)
            )

        val failed = failureVectors(results)

        // Group by exception type
        val groups = failed
            .groupBy {
                case (_, _, _, Left(ex)) =>
                    if ex.getMessage.contains("Out of budget") then "Out of budget"
                    else ex.getClass.getSimpleName
                case _ => "Unexpected success"
            }
            .toSeq
            .sortBy(-_._2.length)

        val failsRate =
            (BigDecimal(100.0) * failed.length / vectors.length)
                .setScale(2, BigDecimal.RoundingMode.UP)
        val successRate = 100.0 - failsRate

        println(s"Vectors: ${vectors.length}")
        println(s"Failed: ${failed.length}")
        println(s"Fails rate: $failsRate%")
        println(s"Success rate: $successRate%")

        println(s"\nFailures by exception type (with message):")
        groups.foreach { case (exType, failures) =>
            println(s"  $exType: ${failures.length}")
        }

        println(s"\nFailures details:")
        groups.foreach { case (exType, failures) =>
            println(s"$exType:")
            failures.foreach { case (vectorName, name, expectedSuccess, result) =>
                println(s"    $vectorName / $name")
                println(s"      expectedSuccess=$expectedSuccess")
                result match {
                    case Left(ex) =>
                        println(s"      error: ${ex.getClass.getSimpleName}: ${ex.getMessage}")
                    case Right(_) => println(s"      (unexpectedly succeeded)")
                }
            }
        }

        failed
    }

}
