package scalus.testing.conformance

import io.bullet.borer.Cbor
import org.scalatest.BeforeAndAfterEach
import org.scalatest.funsuite.*
import scalus.uplc.builtin.Data.toData

import java.io.File
import scalus.uplc.builtin.platform
import scalus.cardano.ledger.*
import scalus.cardano.ledger.rules.*
import scalus.cardano.onchain.plutus
import scalus.testing.conformance.CardanoLedgerVectors.*
import scalus.uplc.eval.ExBudget
import scalus.utils.Hex

/** Test to compare ScriptContext generated by Scalus vs cardano-ledger.
  *
  * This test helps investigate budget differences by examining if the ScriptContext encoding differs
  * between Scalus and cardano-ledger.
  */
class ScriptContextComparisonTest extends AnyFunSuite with BeforeAndAfterEach {

    override def afterEach(): Unit = {
        // Clean up script-*.flat files created by debugDumpFilesForTesting
        val currentDir = new File(".")
        currentDir.listFiles().filter(_.getName.matches("script-.*\\.flat")).foreach(_.delete())
        super.afterEach()
    }

    test("Dump ScriptContext for failing test vector") {
        val vectorName =
            "UTXOS.PlutusV1.can use regular inputs for reference"

        println(s"=== ScriptContext Comparison Test ===")
        println(s"Vector: $vectorName")
        println()

        for case (path, vector) <- loadVector(vectorName) do {
            println(s"--- Processing: $path ---")

            // Parse transaction
            val tx = Transaction.fromCbor(Hex.hexToBytes(vector.cbor))
            println(s"Transaction ID: ${tx.id.toHex}")

            // Load ledger state
            val ledgerState = LedgerState.fromCbor(Hex.hexToBytes(vector.oldLedgerState))
            val state = ledgerState.ruleState
            val utxos = state.utxos

            println(s"UTxO count: ${utxos.size}")

            // Load protocol params - first try explicit pparamsHash, then fall back to searching
            val paramsOpt = vector.pparamsHash
                .flatMap(hash => ConwayProtocolParams.loadFromHash(pparamsDir, hash))
                .orElse(
                  ConwayProtocolParams
                      .extractPparamsHash(vector.oldLedgerState, pparamsDir)
                      .flatMap(hash => ConwayProtocolParams.loadFromHash(pparamsDir, hash))
                )
                .map(_.toProtocolParams)

            val params = paramsOpt.getOrElse(UtxoEnv.default.params)
            println(s"Protocol version: ${params.protocolVersion}")
            println(s"Cost models available: ${params.costModels.models.keys.toSeq.sorted}")

            // Get redeemers from transaction
            val redeemers = tx.witnessSet.redeemers.map(_.value.toMap).getOrElse(Map.empty)
            println(s"Redeemer count: ${redeemers.size}")

            for ((tag, index), (data, exUnits)) <- redeemers do {
                println(s"\nRedeemer: $tag[$index]")
                println(s"  Budget in redeemer: mem=${exUnits.memory}, cpu=${exUnits.steps}")
            }

            // Create evaluator to get ScriptContext
            val evaluator = PlutusScriptEvaluator(
              slotConfig = SlotConfig.mainnet,
              initialBudget = ExBudget.fromCpuAndMemory(
                params.maxTxExecutionUnits.steps,
                params.maxTxExecutionUnits.memory
              ),
              protocolMajorVersion = params.protocolVersion.toMajor,
              costModels = params.costModels,
              mode = EvaluatorMode.EvaluateAndComputeCost, // Use compute mode to get budget
              debugDumpFilesForTesting = false
            )

            try {
                val results = evaluator.evalPlutusScriptsWithContexts(tx, utxos)

                for (redeemer, scriptContext, scriptHash) <- results do {
                    println(s"\n=== ScriptContext for ${redeemer.tag}[${redeemer.index}] ===")
                    println(s"Script hash: ${scriptHash.toHex}")
                    println(
                      s"Computed budget: mem=${redeemer.exUnits.memory}, cpu=${redeemer.exUnits.steps}"
                    )

                    // Extract and show TxInfo fields for comparison
                    scriptContext match {
                        case v1ctx: scalus.cardano.onchain.plutus.v1.ScriptContext =>
                            val ctxData = v1ctx.toData
                            val ctxCbor = Cbor.encode(ctxData).toByteArray
                            val ctxHex = Hex.bytesToHex(ctxCbor)

                            println(s"ScriptContext CBOR size: ${ctxCbor.length} bytes")
                            println(s"ScriptContext CBOR hex (first 200 chars):")
                            println(s"  ${ctxHex.take(200)}...")
                            println(s"\nScriptContext Data structure:")
                            println(s"  ${ctxData.toJson.take(500)}...")

                            val txInfo = v1ctx.txInfo
                            println(s"\n  TxInfo V1 fields:")
                            println(s"    inputs count: ${txInfo.inputs.length}")
                            println(s"    outputs count: ${txInfo.outputs.length}")
                            println(s"    signatories count: ${txInfo.signatories.length}")
                            println(s"    data count: ${txInfo.data.length}")
                            println(s"    txId: ${txInfo.id.hash.toHex}")

                            // Show input ordering (critical for determinism)
                            println(s"\n  Input TxOutRefs (in order):")
                            txInfo.inputs.foreach { txInInfo =>
                                println(
                                  s"    ${txInInfo.outRef.id.hash.toHex}#${txInInfo.outRef.idx}"
                                )
                            }

                        case v2ctx: scalus.cardano.onchain.plutus.v2.ScriptContext =>
                            val ctxData = v2ctx.toData
                            val ctxCbor = Cbor.encode(ctxData).toByteArray
                            val ctxHex = Hex.bytesToHex(ctxCbor)

                            println(s"ScriptContext CBOR size: ${ctxCbor.length} bytes")
                            println(s"ScriptContext CBOR hex (first 200 chars):")
                            println(s"  ${ctxHex.take(200)}...")
                            println(s"\nScriptContext Data structure:")
                            println(s"  ${ctxData.toJson.take(500)}...")

                            val txInfo = v2ctx.txInfo
                            println(s"\n  TxInfo V2 fields:")
                            println(s"    inputs count: ${txInfo.inputs.length}")
                            println(s"    referenceInputs count: ${txInfo.referenceInputs.length}")
                            println(s"    outputs count: ${txInfo.outputs.length}")
                            println(s"    signatories count: ${txInfo.signatories.length}")
                            println(s"    txId: ${txInfo.id.hash.toHex}")

                        case v3ctx: scalus.cardano.onchain.plutus.v3.ScriptContext =>
                            val ctxData = v3ctx.toData
                            val ctxCbor = Cbor.encode(ctxData).toByteArray
                            val ctxHex = Hex.bytesToHex(ctxCbor)

                            println(s"ScriptContext CBOR size: ${ctxCbor.length} bytes")
                            println(s"ScriptContext CBOR hex (first 200 chars):")
                            println(s"  ${ctxHex.take(200)}...")
                            println(s"\nScriptContext Data structure:")
                            println(s"  ${ctxData.toJson.take(500)}...")

                            val txInfo = v3ctx.txInfo
                            println(s"\n  TxInfo V3 fields:")
                            println(s"    inputs count: ${txInfo.inputs.length}")
                            println(s"    referenceInputs count: ${txInfo.referenceInputs.length}")
                            println(s"    outputs count: ${txInfo.outputs.length}")
                            println(s"    signatories count: ${txInfo.signatories.length}")
                            println(s"    txId: ${txInfo.id.hash.toHex}")

                        case _ =>
                            println(s"  Unknown ScriptContext type: ${scriptContext.getClass}")
                    }
                }
            } catch {
                case e: Exception =>
                    println(s"Error during evaluation: ${e.getMessage}")
                    e.printStackTrace()
            }

            println()
        }
    }

    test("Dump applied program for comparison with Haskell uplc") {
        val vectorName =
            "UTXOS.PlutusV1.can use regular inputs for reference"

        println(s"\n=== Dump Applied Program for Haskell Comparison ===")
        println(s"Vector: $vectorName")
        println()
        println("To compare with Haskell uplc, run:")
        println("  uplc evaluate --input script-<hash>-<lang>-<tag>-<idx>.flat --counting")
        println()

        for case (path, vector) <- loadVector(vectorName) do {
            val tx = Transaction.fromCbor(Hex.hexToBytes(vector.cbor))
            val ledgerState = LedgerState.fromCbor(Hex.hexToBytes(vector.oldLedgerState))
            val state = ledgerState.ruleState
            val utxos = state.utxos

            val paramsOpt = vector.pparamsHash
                .flatMap(hash => ConwayProtocolParams.loadFromHash(pparamsDir, hash))
                .orElse(
                  ConwayProtocolParams
                      .extractPparamsHash(vector.oldLedgerState, pparamsDir)
                      .flatMap(hash => ConwayProtocolParams.loadFromHash(pparamsDir, hash))
                )
                .map(_.toProtocolParams)

            val params = paramsOpt.getOrElse(UtxoEnv.default.params)

            // Create evaluator with debug dump enabled
            val evaluator = PlutusScriptEvaluator(
              slotConfig = SlotConfig.mainnet,
              initialBudget = ExBudget.fromCpuAndMemory(
                params.maxTxExecutionUnits.steps,
                params.maxTxExecutionUnits.memory
              ),
              protocolMajorVersion = params.protocolVersion.toMajor,
              costModels = params.costModels,
              mode = EvaluatorMode.EvaluateAndComputeCost,
              debugDumpFilesForTesting = true // Enable dump
            )

            val results = evaluator.evalPlutusScriptsWithContexts(tx, utxos)

            for (redeemer, scriptContext, scriptHash) <- results do {
                println(s"\n--- ${redeemer.tag}[${redeemer.index}] ---")
                println(s"Script hash: ${scriptHash.toHex}")
                println(
                  s"Computed budget: mem=${redeemer.exUnits.memory}, cpu=${redeemer.exUnits.steps}"
                )

                // Dump ScriptContext
                scriptContext match {
                    case v1ctx: scalus.cardano.onchain.plutus.v1.ScriptContext =>
                        val ctxData = v1ctx.toData
                        val ctxCbor = Cbor.encode(ctxData).toByteArray
                        val ctxFilename =
                            s"/tmp/scalus_scriptcontext_${redeemer.tag.toString.toLowerCase}_${redeemer.index}.cbor"
                        platform.writeFile(ctxFilename, ctxCbor)
                        println(s"Wrote ScriptContext CBOR to: $ctxFilename")
                        println(s"ScriptContext CBOR hex: ${Hex.bytesToHex(ctxCbor)}")

                    case v2ctx: scalus.cardano.onchain.plutus.v2.ScriptContext =>
                        val ctxData = v2ctx.toData
                        val ctxCbor = Cbor.encode(ctxData).toByteArray
                        val ctxFilename =
                            s"/tmp/scalus_scriptcontext_${redeemer.tag.toString.toLowerCase}_${redeemer.index}.cbor"
                        platform.writeFile(ctxFilename, ctxCbor)
                        println(s"Wrote ScriptContext CBOR to: $ctxFilename")

                    case v3ctx: scalus.cardano.onchain.plutus.v3.ScriptContext =>
                        val ctxData = v3ctx.toData
                        val ctxCbor = Cbor.encode(ctxData).toByteArray
                        val ctxFilename =
                            s"/tmp/scalus_scriptcontext_${redeemer.tag.toString.toLowerCase}_${redeemer.index}.cbor"
                        platform.writeFile(ctxFilename, ctxCbor)
                        println(s"Wrote ScriptContext CBOR to: $ctxFilename")

                    case _ =>
                        println(s"Unknown ScriptContext type: ${scriptContext.getClass}")
                }
            }

            println(s"\nApplied programs dumped to script-*.flat by evaluator")
            println("To evaluate with Haskell uplc:")
            println("  uplc evaluate --input script-<hash>-<lang>-<tag>-<idx>.flat --counting")
        }
    }

    test("Compare budget with EvaluateAndComputeCost mode") {
        val vectorName =
            "UTXOS.PlutusV1.can use regular inputs for reference"

        for case (path, vector) <- loadVector(vectorName) do {
            val tx = Transaction.fromCbor(Hex.hexToBytes(vector.cbor))
            val ledgerState = LedgerState.fromCbor(Hex.hexToBytes(vector.oldLedgerState))
            val state = ledgerState.ruleState
            val utxos = state.utxos

            val paramsOpt = vector.pparamsHash
                .flatMap(hash => ConwayProtocolParams.loadFromHash(pparamsDir, hash))
                .orElse(
                  ConwayProtocolParams
                      .extractPparamsHash(vector.oldLedgerState, pparamsDir)
                      .flatMap(hash => ConwayProtocolParams.loadFromHash(pparamsDir, hash))
                )
                .map(_.toProtocolParams)

            val params = paramsOpt.getOrElse(UtxoEnv.default.params)

            // Get original redeemer budgets
            val originalRedeemers = tx.witnessSet.redeemers.map(_.value.toMap).getOrElse(Map.empty)

            // Evaluate with compute mode
            val evaluator = PlutusScriptEvaluator(
              slotConfig = SlotConfig.mainnet,
              initialBudget = ExBudget.fromCpuAndMemory(
                params.maxTxExecutionUnits.steps,
                params.maxTxExecutionUnits.memory
              ),
              protocolMajorVersion = params.protocolVersion.toMajor,
              costModels = params.costModels,
              mode = EvaluatorMode.EvaluateAndComputeCost,
              debugDumpFilesForTesting = false
            )

            val results = evaluator.evalPlutusScriptsWithContexts(tx, utxos)

            println(s"\n=== Budget Comparison for $path ===")
            for (redeemer, _, _) <- results do {
                val key = (redeemer.tag, redeemer.index)
                originalRedeemers.get(key) match {
                    case Some((_, origExUnits)) =>
                        val memDiff = redeemer.exUnits.memory - origExUnits.memory
                        val cpuDiff = redeemer.exUnits.steps - origExUnits.steps
                        println(s"${redeemer.tag}[${redeemer.index}]:")
                        println(s"  Original:  mem=${origExUnits.memory}, cpu=${origExUnits.steps}")
                        println(
                          s"  Computed:  mem=${redeemer.exUnits.memory}, cpu=${redeemer.exUnits.steps}"
                        )
                        println(
                          s"  Diff:      mem=${if memDiff >= 0 then "+" else ""}$memDiff, cpu=${if cpuDiff >= 0 then "+" else ""}$cpuDiff"
                        )
                    case None =>
                        println(s"${redeemer.tag}[${redeemer.index}]: no original redeemer found")
                }
            }
        }
    }
}
