package scalus.uplc.eval

import scalus.uplc.eval.mincont.{JIT as MincontJIT}

import scalus.*
import scalus.uplc.{DeBruijnedProgram, Term}
import java.nio.file.{Files, Paths}

/** Test harness to analyze JIT-generated bytecode and assembly.
  *
  * Run with JVM flags to see compilation details:
  * - -XX:+PrintCompilation
  * - -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining
  * - -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly (requires hsdis)
  * - -XX:CompileCommand=print,*ContinuationJitRepr.eval
  * - -XX:CompileCommand=print,*JIT*.apply
  *
  * To dump generated classes:
  * - -Dscala.quoted.dumpClassesTo=jit-classes
  */
object AnalyzeJITBytecode {

    def main(args: Array[String]): Unit = {
        println("=== JIT Bytecode Analysis ===\n")

        // Test 1: Simple arithmetic
        println("1. Simple arithmetic test")
        testSimpleArithmetic()

        // Test 2: Load real contract
        println("\n2. Real contract (auction_1-1.flat)")
        testRealContract()

        // Test 3: Hot loop to trigger JIT compilation
        println("\n3. Running hot loop to trigger HotSpot compilation...")
        runHotLoop()

        println("\n=== Analysis Complete ===")
    }

    def testSimpleArithmetic(): Unit = {
        // (λx. (λy. x + y)) 5 10
        // This should generate: AddInteger builtin application
        val term = Term.Apply(
            Term.Apply(
                Term.LamAbs(
                    "x",
                    Term.LamAbs(
                        "y",
                        Term.Apply(
                            Term.Apply(
                                Term.Builtin(scalus.uplc.DefaultFun.AddInteger),
                                Term.Var(scalus.uplc.NamedDeBruijn("x", 2))
                            ),
                            Term.Var(scalus.uplc.NamedDeBruijn("y", 1))
                        )
                    )
                ),
                Term.Const(scalus.uplc.Constant.Integer(5))
            ),
            Term.Const(scalus.uplc.Constant.Integer(10))
        )

        val params = MachineParams.defaultPlutusV2PostConwayParams

        println("  Compiling with JIT...")
        val start = System.nanoTime()
        val jitted = MincontJIT.jitUplc(term)
        val compileTime = (System.nanoTime() - start) / 1_000_000.0
        println(s"  Compilation took: ${compileTime}ms")

        println("  Executing JIT version...")
        val result = jitted(NoLogger, NoBudgetSpender, params)
        println(s"  Result: $result")

        // Compare with CEK
        println("  Executing CEK version...")
        given vm: PlutusVM = PlutusVM.makePlutusV2VM()
        val cekResult = vm.evaluateDeBruijnedTerm(term, NoBudgetSpender, NoLogger)
        println(s"  CEK Result: $cekResult")
    }

    def testRealContract(): Unit = {
        val path = Paths.get("bench/src/main/resources/data/auction_1-1.flat")
        if (!Files.exists(path)) {
            println("  Skipping: auction_1-1.flat not found")
            return
        }

        val bytes = Files.readAllBytes(path)
        val program = DeBruijnedProgram.fromFlatEncoded(bytes)
        val params = MachineParams.defaultPlutusV2PostConwayParams

        println("  Compiling with JIT...")
        val start = System.nanoTime()
        val jitted = MincontJIT.jitUplc(program.term)
        val compileTime = (System.nanoTime() - start) / 1_000_000.0
        println(s"  Compilation took: ${compileTime}ms")

        println("  Warming up JIT (5 iterations)...")
        for (i <- 1 to 5) {
            jitted(NoLogger, NoBudgetSpender, params)
        }

        println("  Executing JIT version (timed)...")
        val execStart = System.nanoTime()
        val result = jitted(NoLogger, NoBudgetSpender, params)
        val execTime = (System.nanoTime() - execStart) / 1_000.0
        println(s"  Execution took: ${execTime}µs")
        println(s"  Result: $result")
    }

    def runHotLoop(): Unit = {
        // Simple term that will be executed many times
        val term = Term.Apply(
            Term.Apply(
                Term.Builtin(scalus.uplc.DefaultFun.AddInteger),
                Term.Const(scalus.uplc.Constant.Integer(42))
            ),
            Term.Const(scalus.uplc.Constant.Integer(58))
        )

        val params = MachineParams.defaultPlutusV2PostConwayParams
        val jitted = MincontJIT.jitUplc(term)

        // Warm up
        for (i <- 1 to 1000) {
            jitted(NoLogger, NoBudgetSpender, params)
        }

        println("  Running benchmark loop (10000 iterations)...")
        val start = System.nanoTime()
        var sum = BigInt(0)
        for (i <- 1 to 10000) {
            val result = jitted(NoLogger, NoBudgetSpender, params)
            sum += result.asInstanceOf[BigInt]
        }
        val elapsed = (System.nanoTime() - start) / 1_000_000.0
        println(s"  Total time: ${elapsed}ms")
        println(s"  Per iteration: ${elapsed / 10000}ms")
        println(s"  Sum (to prevent DCE): $sum")

        // Now run CEK for comparison
        given vm: PlutusVM = PlutusVM.makePlutusV2VM()

        // Warm up CEK
        for (i <- 1 to 1000) {
            vm.evaluateDeBruijnedTerm(term, NoBudgetSpender, NoLogger)
        }

        println("  Running CEK benchmark loop (10000 iterations)...")
        val cekStart = System.nanoTime()
        var cekSum = BigInt(0)
        for (i <- 1 to 10000) {
            val result = vm.evaluateDeBruijnedTerm(term, NoBudgetSpender, NoLogger)
            result match {
                case Term.Const(scalus.uplc.Constant.Integer(i)) => cekSum = cekSum + i
                case _ => ()
            }
        }
        val cekElapsed = (System.nanoTime() - cekStart) / 1_000_000.0
        println(s"  Total time: ${cekElapsed}ms")
        println(s"  Per iteration: ${cekElapsed / 10000}ms")
        println(s"  Speedup: ${cekElapsed / elapsed}x")
    }
}
