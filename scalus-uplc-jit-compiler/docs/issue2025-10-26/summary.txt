JIT Compilation Issue - October 26, 2025
=========================================

ISSUE DESCRIPTION
-----------------
JIT benchmarks appear to hang when compiling large UPLC programs (e.g., auction_1-1.flat).

INVESTIGATION FINDINGS
----------------------
The issue is caused by the trampolining code added in commit 56799fe9. 
With trampolining code: OutOfMemoryError after ~8.5 minutes
Without trampolining code: SUCCESS in ~94 seconds

Root Cause:
- The trampolining code adds extremely complex nested try-catch blocks for every Apply node
- This creates massive quoted expression trees that the Scala 3 staging compiler cannot handle
- The Scala 3 compiler's TreeTypeMap runs out of memory trying to process these complex trees
- The auction program (3.7KB flatfile, ~540 UPLC nodes) is too large with trampolining enabled

Evidence:
- Test ran for ~8.5 minutes (520+ seconds) before crashing
- Error: java.lang.OutOfMemoryError: Java heap space
- Stack trace shows failure in: dotty.tools.dotc.ast.TreeTypeMap.transform
- The genCode function successfully processes all nodes (~537-548 nodes)
- The hang/crash occurs in staging.run, NOT during quote generation

Timeline of Execution:
1. Program loads successfully
2. genCode processes ~537-548 UPLC nodes quickly (< 30 seconds)
3. staging.run attempts to compile the generated quoted expression tree
4. After ~8.5 minutes, OutOfMemoryError is thrown
5. Process crashes

IMPACT OF TRAMPOLINING CODE
----------------------------
Recent trampolining changes (commit 56799fe9) made the problem worse by adding:
- Complex nested try-catch blocks for every Apply node
- Exception handling and continuation tracking in LamAbs nodes
- Additional stack depth tracking code

This increases the size and complexity of the generated expression tree, 
making the memory issue more severe.

Test Results with Simplified Code:
✓ JITTest: PASSED - basic JIT functionality works
✓ TestJITHang (auction program): SUCCESS in ~94 seconds
✓ No OutOfMemoryError
✓ Compilation completes successfully

Conclusion: The trampolining code IS the root cause, not just a contributing factor.

LOCATION OF FAILURE
-------------------
- Phase: COMPILATION (JIT compilation via staging.run)
- NOT during: Quote generation (genCode)
- NOT during: Execution of compiled code

Code Path:
JIT.jitUplc() 
  -> staging.run { ... }        // <- Memory exhaustion happens here
     -> genCodeFromTerm()        // <- This completes successfully
        -> Scala 3 compiler processes quoted expressions
        -> TreeTypeMap.transform() runs out of memory

CONCLUSION
----------
The trampolining code (commit 56799fe9) breaks JIT compilation for large programs:
1. WITHOUT trampolining: Auction program compiles successfully in ~94 seconds
2. WITH trampolining: OutOfMemoryError after ~8.5 minutes
3. The complex nested try-catch and exception handling in trampolining code creates 
   expression trees too large for Scala 3's staging compiler to handle

SOLUTIONS
----------
- Pattern val f = ()=>${genCode(...)} (where genCode is our recursive generated long expression) slowdown computation. 
Avoid it and use pass by name instead.

TEST FILES
----------
- scalus-uplc-jit-compiler/src/test/scala/scalus/uplc/eval/TestJITHang.scala
- scalus-uplc-jit-compiler/src/test/scala/scalus/uplc/eval/TestJITHangDetailed.scala
- bench/src/main/scala/scalus/uplc/eval/JITBenchmark.scala
- Test program: bench/src/main/resources/data/auction_1-1.flat (3.7KB)

RELATED CODE
------------
- scalus-uplc-jit-compiler/src/main/scala/scalus/uplc/eval/JIT.scala
  - jitUplc() method (line ~556)
  - genCodeFromTerm() method
  - Term.Apply case (with trampolining)
  - Term.LamAbs case (with trampolining)
